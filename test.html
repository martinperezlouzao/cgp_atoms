
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js test</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background:#000;
				color:#fff;
				padding:0;
				margin:0;
				font-weight: bold;
				overflow:hidden;
			}
			a {color: #0080ff; }
			b { color: lightgreen }
		</style>
	</head>
	<body>

		<script src="..\three.js-master\three.js-master\build\three.js"></script>
		<script src="..\three.js-master\three.js-master\examples\js\libs\stats.min.js"></script>
		<script src="..\three.js-master\three.js-master\examples\js\controls\OrbitControls.js"></script>
		<script src="..\three.js-master\three.js-master\examples\js\loaders\OBJLoader.js"></script>
		<script src="..\three.js-master\three.js-master\examples\js\WebGL.js"></script>
		<script src="..\three.js-master\three.js-master\examples\js\libs\stats.min.js"></script>
		<script src='..\three.js-master\three.js-master\examples\js\libs\dat.gui.min.js'></script>

		<script>
			var atomNames = [];
			var atomsToDraw = [];
			var groups = [];
			var params;
			var activeSelection = 0;
			var atomType = function(name, coordinates, geometry, material){
					this.name = name;
					this.coordinates = coordinates;
					this.geometry = geometry;
					this.material = material;
				return this;
			};
			var camera, controls, scene, renderer;
			var ambientLight, light, r = 0.0;
			THREE.Cache.enabled = true;
			var file = new THREE.FileLoader();
			var lines;

			//----------------------
			var turn = 0, cubeCamera1, cubeCamera2;
			//---------------------------------


			file.load(
				// resource URL
				'points.xyz',
				// onLoad callback
				function ( data ) {
					// output the text to the console
					lines = data.split('\n');
					var line;
					var coordinates = [];
					
					for (var i = 0; i < lines.length; i++){
						line = lines[i].split(' ');
						
						if(line.length > 1){
							for(var j=0;j<line.length;j++){
								if(line[j] != ''){
									var point = parseFloat(line[j]);
									if (! isNaN(point)){
										coordinates.push(point);
									}
									else{
										coordinates.push(line[j]);
										if(!atomNames.includes(line[j])){
											atomNames.push(line[j]);
										}
									}
								}
							}
						}

						if(coordinates.length == 4){
							atomsToDraw.push(coordinates);
						}
						
						coordinates = [];
					}

					init();
				},				
				// onProgress callback
				function ( xhr ) {
					console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );
				},
				// onError callback
				function ( err ) {
					console.error( 'An error happened loading the file' );
				}
			);
			

			
			function init(){				
				var SCREEN_WIDTH = window.innerWidth;
				var SCREEN_HEIGHT = window.innerHeight;
				
				var container = document.createElement( 'div' );
				document.body.appendChild( container );
				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );
					
				scene = new THREE.Scene();
				var aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
					
				camera = new THREE.PerspectiveCamera( 45, aspect, 2, 10000 );
				camera.position.set( 10, 10, 30 );
				camera.lookAt( scene.position );


				controls = new THREE.OrbitControls( camera, renderer.domElement );
				controls.enableZoom = true;
				controls.enableDamping = true;
				controls.update();						
				ambientLight = new THREE.AmbientLight(0x000000);
				scene.add(ambientLight);
				
				var light = new THREE.DirectionalLight( 0xffffff , 1);
				light.position.set(10,10,30);
				scene.add( light );

				var light2 = new THREE.DirectionalLight( 0xffffff , 1);
				light2.position.set(-10,-10,-30);
				scene.add( light2 );

				//------------------------------
				cubeCamera1 = new THREE.CubeCamera( 2, 10000, 512 );
				scene.add( cubeCamera1 );
				cubeCamera2 = new THREE.CubeCamera( 2, 10000, 512 );
				scene.add( cubeCamera2 );
				//------------------------------

				for(var i=0, j=0;i<atomNames.length;i++){
					var coordinates = [];
					var newAtom = new atomType(atomNames[i],
												coordinates,
												new THREE.SphereGeometry( 0.6, 32, 32 ),
												new THREE.MeshStandardMaterial( {color: 0xff0000,
															metalness: 0.5,
															roughness: 0,
															envMap: cubeCamera2.renderTarget.texture} )
													);
					newAtom.material.color.setHex( Math.random() * 0xffffff );
					for(;j<atomsToDraw.length;j++){
						if(atomsToDraw[j][0] == atomNames[i]){
							newAtom.coordinates.push(atomsToDraw[j]);
						}

						else{
							break;
						}
					}
					
					groups.push(newAtom);
				}

				if(groups.length == 0){
					console.log("Error: no atoms loaded");
					return;
				}	

				for(var i=0;i<groups.length;i++){
					for(var j=0;j<groups[i].coordinates.length;j++){
						var mesh = new THREE.Mesh(groups[i].geometry, groups[i].material);
						mesh.position.set(groups[i].coordinates[j][1], groups[i].coordinates[j][2], groups[i].coordinates[j][3]);
						scene.add(mesh);
					}
				}

				var gui = new dat.GUI();


				params = {
					'Element': groups[activeSelection].name,
					'Color': groups[activeSelection].material.color.getHex(),
					'Roughness': groups[activeSelection].material.roughness,
					'Metalness': groups[activeSelection].material.metalness,
				};

				gui.add( params, "Element", atomNames).onChange( function ( value ) {
					activeSelection = atomNames.indexOf(value);
				} ).listen();
				
				gui.addColor( params, 'Color' ).onChange( function ( val ) {
					groups[activeSelection].material.color.setHex( val );
				} ).listen();
				
				gui.add( params, "Metalness" ).min( 0 ).max( 1 ).onChange( function ( value ) {
					groups[activeSelection].material.metalness = value;
					console.log(gui);
				} );
				gui.add( params, "Roughness" ).min( 0 ).max( 1 ).onChange( function ( value ) {
					groups[activeSelection].material.roughness = value;
				} );
				

				gui.open();

					
				renderer.setClearColor( 0x000000, 1);
				renderer.render( scene, camera );
				animate();
			}
			function animate(){
				requestAnimationFrame( animate );
				
				if ( turn == 0 ) {
					for( var i=0;i<groups.length;i++ ) {
						groups[i].material.envMap = cubeCamera1.renderTarget.texture;
					} 
					cubeCamera2.update( renderer, scene );
					turn = 1;
				} 
				
				else {
					for(var i=0;i<groups.length;i++){
						groups[i].material.envMap = cubeCamera2.renderTarget.texture;
					} 
					cubeCamera1.update( renderer, scene );
					turn = 0;
				}


				controls.update();
				renderer.render( scene, camera );
			}
			
			
		</script>

	</body>
</html>
